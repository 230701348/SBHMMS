<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Smart Battery Health Monitoring and Maintenance System</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <div class="mode">
      <div class="toggle-switch">
        <label class="switch-label">
          <input type="checkbox" class="checkbox" onclick="toggleDarkMode()" />
          <span class="slider"></span>
        </label>
      </div>
    </div>

    <div class="container">
      <div class="top">
        <h1>Battery Dashboard</h1>
      </div>

      <div class="dashboard">
        <div class="card">
          <h2>Current</h2>
          <span id="current">-- A</span>
        </div>
        <div class="card">
          <h2>Voltage</h2>
          <span id="voltage">-- V</span>
        </div>
        <div class="card">
          <h2>Temperature</h2>
          <span id="temp">-- 째C</span>
        </div>
        <div class="card">
          <h2>Power</h2>
          <span id="power">-- W</span>
        </div>
        <div class="card">
          <h2>Energy Used</h2>
          <span id="energy">0.00 Wh</span>
        </div>
        <div class="card">
          <h2>State of Charge</h2>
          <span id="soc">100 %</span>
        </div>
        <div class="card">
          <h2>State of Health</h2>
          <span id="soh">100</span>
        </div>
        <div class="card">
          <h2>Cycles Completed</h2>
          <span id="cycles">0</span>
        </div>
        <div class="card">
          <h2>Efficiency</h2>
          <span id="efficiency">-- %</span>
        </div>
        <div class="card">
          <h2>Remaining Useful Life</h2>
          <span id="rul">-- cycles</span>
        </div>
      </div>

      <div class="charts">
        <canvas id="currentChart" height="300px" width="400px"></canvas>
        <canvas id="voltageChart" height="300px" width="400px"></canvas>
        <canvas id="tempChart" height="300px" width="400px"></canvas>
        <canvas id="powerChart" height="300px" width="400px"></canvas>
      </div>
    </div>

    <script>
      const currentSpan = document.getElementById("current");
      const voltageSpan = document.getElementById("voltage");
      const tempSpan = document.getElementById("temp");

      function toggleDarkMode() {
        document.body.classList.toggle("dark");
      }

      window.serialAPI.listPorts().then((ports) => {
        if (ports.length > 0) {
          window.serialAPI.startSerial(ports[0]);
        }
      });

      const maxDataPoints = 20;

      const createLineChart = (ctx, label, borderColor) => {
        return new Chart(ctx, {
          type: "line",
          data: {
            labels: [],
            datasets: [
              {
                label: label,
                data: [],
                borderColor: borderColor,
                fill: false,
                tension: 0.3,
              },
            ],
          },
          options: {
            responsive: true,
            animation: false,
            scales: {
              x: { display: false },
              y: { beginAtZero: true },
            },
          },
        });
      };

      const currentChart = createLineChart(
        document.getElementById("currentChart"),
        "Current (A)",
        "#f44336"
      );
      const voltageChart = createLineChart(
        document.getElementById("voltageChart"),
        "Voltage (V)",
        "#2196f3"
      );
      const tempChart = createLineChart(
        document.getElementById("tempChart"),
        "Temperature (째C)",
        "#4caf50"
      );
      const powerChart = createLineChart(
        document.getElementById("powerChart"),
        "Power (W)",
        "#ff9800"
      );

      const updateChart = (chart, value) => {
        const now = new Date().toLocaleTimeString();
        chart.data.labels.push(now);
        chart.data.datasets[0].data.push(parseFloat(value));
        if (chart.data.labels.length > maxDataPoints) {
          chart.data.labels.shift();
          chart.data.datasets[0].data.shift();
        }
        chart.update();
      };

      let model;

      async function trainAndSaveModel() {
        const trainingData = [
          { current: 0.05, voltage: 1.5, temp: 32, rul: 500 },
          { current: 0.06, voltage: 1.49, temp: 32.5, rul: 495 },
          { current: 0.1, voltage: 1.4, temp: 33, rul: 450 },
          { current: 0.11, voltage: 1.38, temp: 32.8, rul: 440 },
          { current: 0.2, voltage: 1.3, temp: 33, rul: 400 },
          { current: 0.21, voltage: 1.28, temp: 33.2, rul: 390 },
          { current: 0.3, voltage: 1.2, temp: 34, rul: 350 },
          { current: 0.32, voltage: 1.18, temp: 34.1, rul: 340 },
          { current: 0.4, voltage: 1.1, temp: 34, rul: 300 },
          { current: 0.42, voltage: 1.08, temp: 34.2, rul: 290 },
          { current: 0.5, voltage: 1.0, temp: 32, rul: 250 },
          { current: 0.52, voltage: 0.98, temp: 32.3, rul: 240 },
          { current: 0.6, voltage: 0.9, temp: 33, rul: 200 },
          { current: 0.62, voltage: 0.88, temp: 33.1, rul: 190 },
          { current: 0.7, voltage: 0.8, temp: 32, rul: 150 },
          { current: 0.72, voltage: 0.78, temp: 32.2, rul: 140 },
          { current: 0.8, voltage: 0.7, temp: 34, rul: 100 },
          { current: 0.82, voltage: 0.68, temp: 34.1, rul: 90 },
          { current: 0.9, voltage: 0.6, temp: 34, rul: 50 },
          { current: 0.92, voltage: 0.58, temp: 34.2, rul: 40 },
        ];

        const inputs = trainingData.map((d) => [d.current, d.voltage, d.temp]);
        const labels = trainingData.map((d) => d.rul);

        const model = tf.sequential();
        model.add(
          tf.layers.dense({ units: 32, activation: "relu", inputShape: [3] })
        );
        model.add(tf.layers.dense({ units: 16, activation: "relu" }));
        model.add(tf.layers.dense({ units: 1, activation: "linear" }));

        model.compile({
          optimizer: "adam",
          loss: "meanSquaredError",
        });

        const xs = tf.tensor2d(inputs);
        const ys = tf.tensor2d(labels, [labels.length, 1]);

        await model.fit(xs, ys, {
          epochs: 300,
          batchSize: 10,
          callbacks: {
            onEpochEnd: (epoch, logs) => {
              console.log(`Epoch ${epoch}: loss = ${logs.loss}`);
            },
          },
        });

        await model.save("localstorage://battery-life-model");
        console.log("Model trained and saved to localStorage.");
      }

      async function loadModel() {
        try {
          model = await tf.loadLayersModel("localstorage://battery-life-model");
          console.log("Model loaded from localStorage.");
        } catch (error) {
          console.log("No saved model found, training a new one...");
          await trainAndSaveModel();
        }
      }

      loadModel();

      async function predictRUL(current, voltage, temperature) {
        if (!model) {
          console.log("Model not loaded yet.");
          return;
        }
        if (voltage <= 0 || current < 0) {
          document.getElementById("rul").textContent = `0 cycles`;
          return;
        }
        const input = tf.tensor2d([[current, voltage, temperature]]);
        const prediction = model.predict(input);
        const predictedRUL = prediction.dataSync()[0];
        document.getElementById("rul").textContent = `${predictedRUL.toFixed(
          2
        )} cycles`;
      }

      window.serialAPI.onData((data) => {
        try {
          const match = data.match(
            /Current: (.*?) A \| Voltage: (.*?) V \| Temp: (.*?) 째C/
          );
          if (match) {
            const [_, current, voltage, temp] = match;
            currentSpan.textContent = `${current} A`;
            voltageSpan.textContent = `${voltage} V`;
            tempSpan.textContent = `${temp} 째C`;

            updateChart(currentChart, current);
            updateChart(voltageChart, voltage);
            updateChart(tempChart, temp);

            const resistance = 220;
            const power = parseFloat(voltage) ** 2 / resistance;
            document.getElementById("power").textContent = `${power.toFixed(
              2
            )} W`;
            updateChart(powerChart, power);

            const ratedVoltage = 1.6;
            const idealInputPower = ratedVoltage * parseFloat(current);
            const efficiency =
              idealInputPower > 0 ? (power / idealInputPower) * 100 : 0;
            document.getElementById(
              "efficiency"
            ).textContent = `${efficiency.toFixed(2)} %`;

            estimateSoCFromVoltage(voltage);
            estimateSoHFromVoltage(voltage);
            trackChargeCycle(voltage, current);

            const currentVal = parseFloat(current);
            const voltageVal = parseFloat(voltage);
            const tempVal = parseFloat(temp);
            predictRUL(currentVal, voltageVal, tempVal);
          }
        } catch (e) {
          console.log("Data parse error", e);
        }
      });

      function estimateSoCFromVoltage(voltage) {
        voltage = parseFloat(voltage);
        const minV = 1.1;
        const maxV = 1.6;
        let soc = ((voltage - minV) / (maxV - minV)) * 100;
        soc = Math.min(100, Math.max(0, soc.toFixed(1)));
        document.getElementById("soc").textContent = `${soc} %`;
      }

      function estimateSoHFromVoltage(voltage) {
        voltage = parseFloat(voltage);
        const ratedVoltage = 1.6;
        const minVoltage = 1.1;
        let soh = ((voltage - minVoltage) / (ratedVoltage - minVoltage)) * 100;
        soh = Math.min(100, Math.max(0, soh.toFixed(1)));
        document.getElementById("soh").textContent = `${soh}`;
      }

      let totalEnergy = 0;
      let lastTimestamp = Date.now();
      let cycleCount = 0;
      const energyPerCycle = 1.5 * 2 * 3600;
      function trackChargeCycle(voltage, current) {
        voltage = parseFloat(voltage);
        current = parseFloat(current);
        const now = Date.now();
        const deltaTime = (now - lastTimestamp) / 1000;
        lastTimestamp = now;
        const energy = voltage * current * deltaTime;
        totalEnergy += energy;
        document.getElementById("energy").textContent = `${(
          totalEnergy / 3600
        ).toFixed(2)} Wh`;
        if (totalEnergy >= energyPerCycle) {
          cycleCount += 1;
          totalEnergy = 0;
        }
        document.getElementById("cycles").textContent = `${cycleCount}`;
      }
    </script>
  </body>
</html>
