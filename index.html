<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Smart Battery Health Monitoring and Maintenance System</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
      * {
        font-family: "Trebuchet MS";
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg: #f7f7f7;
        --text: #000;
        --card: white;
      }

      body.dark {
        --bg: #121212;
        --text: #fff;
        --card: #2e2e2e;
      }

      body {
        background: var(--bg);
        color: var(--text);
        transition: background 0.3s, color 0.3s;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        gap: 10px;
        align-items: center;
        width: 90%;
        min-height: 90%;
        min-width: 666px;
      }

      .mode {
        position: absolute;
        top: 40px;
        left: 50px;
      }
      .toggle-switch {
        position: relative;
        width: 65px;
        height: 30px;
        --light: #d8dbe0;
        --dark: #28292c;
        --link: rgb(27, 129, 112);
        --link-hover: rgb(24, 94, 82);
      }
      .switch-label {
        position: absolute;
        width: 100%;
        height: 30px;
        background-color: var(--dark);
        border-radius: 25px;
        cursor: pointer;
        border: 3px solid var(--dark);
      }
      .checkbox {
        position: absolute;
        display: none;
      }
      .slider {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 25px;
        -webkit-transition: 0.3s;
        transition: 0.3s;
      }
      .checkbox:checked ~ .slider {
        background-color: var(--light);
      }
      .slider::before {
        content: "";
        position: absolute;
        top: 3px;
        left: 3px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        -webkit-box-shadow: inset 12px -4px 0px 0px var(--light);
        box-shadow: inset 12px -4px 0px 0px var(--light);
        background-color: var(--dark);
        -webkit-transition: 0.3s;
        transition: 0.3s;
      }
      .checkbox:checked ~ .slider::before {
        -webkit-transform: translateX(33px);
        -ms-transform: translateX(33px);
        transform: translateX(33px);
        background-color: var(--dark);
        -webkit-box-shadow: none;
        box-shadow: none;
      }

      .top {
        align-items: left;
      }

      .top h1 {
        font-size: 2rem;
      }

      .dashboard {
        display: flex;
        flex-wrap: wrap;
        flex-direction: row0;
        grid-column: span 3;
        gap: 0.6rem;
        align-items: center;
        height: 100%;
        justify-content: center;
      }

      .card {
        background: var(--card);
        padding: 1rem;
        border-radius: 12px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        width: 220px;
        height: 130px;
        max-width: 220px;
        max-height: 130px;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .card h2 {
        font-size: 1.4rem;
        margin-bottom: 0.5rem;
      }

      .card span {
        font-size: 1.7rem;
        font-weight: bold;
      }

      .card:hover {
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        transform: scale(1.02);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .container .charts {
        display: flex;
        grid-column: span 4;
        gap: 1.5rem;
        width: 100%;
        justify-content: center;
        align-items: center;
      }
      canvas {
        background: var(--card);
        border-radius: 12px;
        padding: 1rem;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        max-width: 350px;
        max-height: 250px;
      }
    </style>
  </head>

  <body>
    <div class="mode">
      <div class="toggle-switch">
        <label class="switch-label">
          <input type="checkbox" class="checkbox" onclick="toggleDarkMode()" />
          <span class="slider"></span>
        </label>
      </div>
    </div>

    <div class="container">
      <div class="top">
        <h1>Battery Dashboard</h1>
      </div>

      <div class="dashboard">
        <div class="card">
          <h2>Current</h2>
          <span id="current">-- A</span>
        </div>
        <div class="card">
          <h2>Voltage</h2>
          <span id="voltage">-- V</span>
        </div>
        <div class="card">
          <h2>Temperature</h2>
          <span id="temp">-- 째C</span>
        </div>
        <div class="card">
          <h2>Power</h2>
          <span id="power">-- W</span>
        </div>
        <div class="card">
          <h2>State of Charge</h2>
          <span id="soc">100 %</span>
        </div>
        <div class="card">
          <h2>State of Health</h2>
          <span id="soh">100</span>
        </div>
        <div class="card">
          <h2>Efficiency</h2>
          <span id="efficiency">-- %</span>
        </div>
        <div class="card">
          <h2>Remaining Useful Life</h2>
          <span id="rul">-- cycles</span>
        </div>
      </div>

      <div class="charts">
        <canvas id="currentChart" height="300px" width="400px"></canvas>
        <canvas id="voltageChart" height="300px" width="400px"></canvas>
        <canvas id="tempChart" height="300px" width="400px"></canvas>
        <canvas id="powerChart" height="300px" width="400px"></canvas>
      </div>
    </div>

    <script>
      const currentSpan = document.getElementById("current");
      const voltageSpan = document.getElementById("voltage");
      const tempSpan = document.getElementById("temp");

      function toggleDarkMode() {
        document.body.classList.toggle("dark");
      }

      window.serialAPI.listPorts().then((ports) => {
        if (ports.length > 0) {
          window.serialAPI.startSerial(ports[0]);
        }
      });

      const maxDataPoints = 20;

      const createLineChart = (ctx, label, borderColor) => {
        return new Chart(ctx, {
          type: "line",
          data: {
            labels: [],
            datasets: [
              {
                label: label,
                data: [],
                borderColor: borderColor,
                fill: false,
                tension: 0.3,
              },
            ],
          },
          options: {
            responsive: true,
            animation: false,
            scales: {
              x: { display: false },
              y: { beginAtZero: true },
            },
          },
        });
      };

      const currentChart = createLineChart(
        document.getElementById("currentChart"),
        "Current (A)",
        "#f44336"
      );
      const voltageChart = createLineChart(
        document.getElementById("voltageChart"),
        "Voltage (V)",
        "#2196f3"
      );
      const tempChart = createLineChart(
        document.getElementById("tempChart"),
        "Temperature (째C)",
        "#4caf50"
      );
      const powerChart = createLineChart(
        document.getElementById("powerChart"),
        "Power (W)",
        "#ff9800"
      );

      const updateChart = (chart, value) => {
        const now = new Date().toLocaleTimeString();
        chart.data.labels.push(now);
        chart.data.datasets[0].data.push(parseFloat(value));
        if (chart.data.labels.length > maxDataPoints) {
          chart.data.labels.shift();
          chart.data.datasets[0].data.shift();
        }
        chart.update();
      };

      let model;

      async function trainAndSaveModel() {
        const trainingData = [
          { current: 0.007, voltage: 1.5, temp: 32, rul: 500 },
          { current: 0.007, voltage: 1.49, temp: 33, rul: 495 },
          { current: 0.007, voltage: 1.4, temp: 34, rul: 450 },
          { current: 0.007, voltage: 1.38, temp: 35, rul: 440 },
          { current: 0.007, voltage: 1.3, temp: 37, rul: 400 },
          { current: 0.007, voltage: 1.28, temp: 38, rul: 390 },
          { current: 0.007, voltage: 1.2, temp: 39, rul: 350 },
          { current: 0.007, voltage: 1.18, temp: 39, rul: 340 },
          { current: 0.007, voltage: 1.1, temp: 40, rul: 300 },
          { current: 0.007, voltage: 1.08, temp: 40.1, rul: 290 },
          { current: 0.007, voltage: 1.0, temp: 40.2, rul: 250 },
          { current: 0.007, voltage: 0.98, temp: 40.3, rul: 240 },
          { current: 0.007, voltage: 0.9, temp: 40.4, rul: 200 },
        ];

        const inputs = trainingData.map((d) => [d.current, d.voltage, d.temp]);
        const labels = trainingData.map((d) => d.rul);

        const model = tf.sequential();
        model.add(
          tf.layers.dense({ units: 32, activation: "relu", inputShape: [3] })
        );
        model.add(tf.layers.dense({ units: 16, activation: "relu" }));
        model.add(tf.layers.dense({ units: 1, activation: "linear" }));

        model.compile({
          optimizer: "adam",
          loss: "meanSquaredError",
        });

        const xs = tf.tensor2d(inputs);
        const ys = tf.tensor2d(labels, [labels.length, 1]);

        await model.fit(xs, ys, {
          epochs: 300,
          batchSize: 10,
          callbacks: {
            onEpochEnd: (epoch, logs) => {
              console.log(`Epoch ${epoch}: loss = ${logs.loss}`);
            },
          },
        });

        await model.save("localstorage://battery-life-model");
        console.log("Model trained and saved to localStorage.");
      }

      async function loadModel() {
        try {
          model = await tf.loadLayersModel("localstorage://battery-life-model");
          console.log("Model loaded from localStorage.");
        } catch (error) {
          console.log("No saved model found, training a new one...");
          await trainAndSaveModel();
        }
      }

      loadModel();

      // trainAndSaveModel();

      async function predictRUL(current, voltage, temperature) {
        if (!model) {
          console.log("Model not loaded yet.");
          return;
        }
        if (voltage <= 0 || current < 0) {
          document.getElementById("rul").textContent = `0 cycles`;
          return;
        }
        const input = tf.tensor2d([[current, voltage, temperature]]);
        const prediction = model.predict(input);
        const predictedRUL = prediction.dataSync()[0];
        document.getElementById("rul").textContent = `${predictedRUL.toFixed(
          2
        )} cycles`;
      }

      window.serialAPI.onData((data) => {
        try {
          const match = data.match(
            /Current: (.*?) A \| Voltage: (.*?) V \| Temp: (.*?) 째C/
          );
          if (match) {
            const [_, current, voltage, temp] = match;
            currentSpan.textContent = `${current} A`;
            voltageSpan.textContent = `${voltage} V`;
            tempSpan.textContent = `${temp} 째C`;

            updateChart(currentChart, current);
            updateChart(voltageChart, voltage);
            updateChart(tempChart, temp);

            const resistance = 220;
            const power = parseFloat(voltage) ** 2 / resistance;
            document.getElementById("power").textContent = `${power.toFixed(
              2
            )} W`;
            updateChart(powerChart, power);

            const ratedVoltage = 1.6;
            const idealInputPower = ratedVoltage * current;
            const efficiency =
              idealInputPower > 0 ? (power / idealInputPower) * 100 : 0;
            document.getElementById(
              "efficiency"
            ).textContent = `${efficiency.toFixed(2)} %`;

            estimateSoCFromVoltage(voltage);
            estimateSoHFromVoltage(voltage);
            trackChargeCycle(voltage, current);

            const currentVal = parseFloat(current);
            const voltageVal = parseFloat(voltage);
            const tempVal = parseFloat(temp);
            predictRUL(currentVal, voltageVal, tempVal);
          }
        } catch (e) {
          console.log("Data parse error", e);
        }
      });

      function estimateSoCFromVoltage(voltage) {
        voltage = parseFloat(voltage);
        const minV = 1.1;
        const maxV = 1.6;
        let soc = ((voltage - minV) / (maxV - minV)) * 100;
        soc = Math.min(100, Math.max(0, soc.toFixed(1)));
        document.getElementById("soc").textContent = `${soc} %`;
      }

      function estimateSoHFromVoltage(voltage) {
        voltage = parseFloat(voltage);
        const ratedVoltage = 1.6;
        const minVoltage = 1.1;
        let soh = ((voltage - minVoltage) / (ratedVoltage - minVoltage)) * 100;
        soh = Math.min(100, Math.max(0, soh.toFixed(1)));
        document.getElementById("soh").textContent = `${soh}`;
      }
    </script>
  </body>
</html>
